# Why NetworkReportImpl Has These Methods - Complete Explanation

## ğŸ¯ **Why Do These Methods Exist?**

### **Answer: Because NetworkReportImpl IMPLEMENTS NetworkReport Interface!**

```java
public class NetworkReportImpl implements NetworkReport {
//                                â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
//                                       â”‚
//                         MUST implement ALL methods from this interface!
    
    // These methods are REQUIRED by the interface:
    @Override
    public Collection<String> getMostActiveGateways() { ... }
    
    @Override
    public Collection<String> getLeastActiveGateways() { ... }
    
    @Override
    public Map<String, Double> getGatewaysLoadRatio() { ... }
    
    @Override
    public SortedMap<Range<LocalDateTime>, Long> getHistogram() { ... }
}
```

**Key concept:** When a class **implements** an interface, it **MUST** provide implementations for **ALL methods** in that interface!

---

## ğŸ“œ **Where These Methods Are Defined**

### **In NetworkReport Interface:**

```java
// File: NetworkReport.java
package com.weather.report.reports;

public interface NetworkReport extends Report<LocalDateTime> {
    
    /**
     * Gateways with the highest number of measurements for the network.
     */
    public Collection<String> getMostActiveGateways();
    //     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    //                â””â”€ Method signature (no implementation!)
    
    /**
     * Gateways with the lowest number of measurements for the network.
     */
    public Collection<String> getLeastActiveGateways();
    
    /**
     * Ratio between measurements of each gateway and the total measurements
     */
    public Map<String, Double> getGatewaysLoadRatio();
    
    /**
     * Returns histogram of measurements grouped into time buckets
     */
    public SortedMap<Range<LocalDateTime>, Long> getHistogram();
}
```

**Interfaces define WHAT methods must exist, not HOW they work!**

---

## ğŸ“‹ **R1 Requirements from README**

From the project README, section **R1 - Network**:

### **NetworkReport Requirements:**

```
The NetworkReport must contain:

â€¢ networkCode: the code passed as input
â€¢ startDate / endDate: the received strings (possibly null)
â€¢ numberOfMeasurements: total number of measurements of the network in the interval

â€¢ mostActiveGateways: gateways with the highest number of measurements â† getMostActiveGateways()

â€¢ leastActiveGateways: gateways with the lowest number of measurements â† getLeastActiveGateways()

â€¢ gatewaysLoadRatio: map <gatewayCode, ratio> â† getGatewaysLoadRatio()
  - ratio is the percentage of measurements generated by a single gateway 
    with respect to the total of the network

â€¢ histogram: map <Range<LocalDateTime>, count> â† getHistogram()
  - The map groups the network's measurements into consecutive time buckets
```

**These are REQUIREMENTS from the project specification!**

---

## ğŸ” **Why Each Method Exists**

### **Reason 1: Interface Contract**

```java
public interface NetworkReport {
    Collection<String> getMostActiveGateways();  // â† Declared here
}

public class NetworkReportImpl implements NetworkReport {
    @Override
    public Collection<String> getMostActiveGateways() {  // â† MUST implement!
        // If you DON'T implement this, Java gives ERROR!
    }
}
```

**If you don't implement it â†’ Compilation ERROR!**

---

### **Reason 2: Project Requirements (R1)**

From the README:
- R1 requires NetworkReport to have these statistics
- These methods provide the required statistics
- Without them, R1 is incomplete

---

### **Reason 3: Tests Expect Them**

The test files call these methods:

```java
// In tests:
NetworkReport report = networkOps.getNetworkReport("NET_01", null, null);

Collection<String> mostActive = report.getMostActiveGateways();
// â†‘ Test expects this method to exist!

Collection<String> leastActive = report.getLeastActiveGateways();
// â†‘ Test expects this method to exist!

Map<String, Double> ratios = report.getGatewaysLoadRatio();
// â†‘ Test expects this method to exist!

SortedMap<Range<LocalDateTime>, Long> histogram = report.getHistogram();
// â†‘ Test expects this method to exist!
```

**Tests will FAIL if these methods don't exist or don't work correctly!**

---

---

# Method 1: getMostActiveGateways()

## ğŸ“‹ **Method Signature**

```java
@Override
public Collection<String> getMostActiveGateways()
```

**Returns:** Collection of gateway codes (Strings)

---

## ğŸ¯ **Purpose**

**Find which gateways produced the MOST measurements for this network.**

If multiple gateways have the same maximum count, return ALL of them.

---

## ğŸ“Š **Example Scenario**

```
Network NET_01 has measurements:
â€¢ GW_0001: 50 measurements
â€¢ GW_0002: 30 measurements
â€¢ GW_0003: 50 measurements  â† Tied with GW_0001!
â€¢ GW_0004: 20 measurements

Question: Which gateways are most active?
Answer: GW_0001 and GW_0003 (both have 50 measurements)

Result: ["GW_0001", "GW_0003"]
```

---

## ğŸ” **How It Works**

### **Step 1: Count measurements per gateway**

```java
Map<String, Long> counts = new HashMap<>();
for (Measurement m : measurements) {
    String gw = m.getGatewayCode();
    counts.put(gw, counts.getOrDefault(gw, 0L) + 1);
}

// Result:
// counts = {
//   "GW_0001": 50,
//   "GW_0002": 30,
//   "GW_0003": 50,
//   "GW_0004": 20
// }
```

---

### **Step 2: Find the maximum count**

```java
long max = 0;
for (Long val : counts.values()) {
    if (val > max) {
        max = val;
    }
}

// Result: max = 50
```

---

### **Step 3: Collect all gateways with maximum count**

```java
List<String> result = new ArrayList<>();
for (Map.Entry<String, Long> entry : counts.entrySet()) {
    if (entry.getValue() == max) {
        result.add(entry.getKey());
    }
}

// Result: ["GW_0001", "GW_0003"]
```

---

## ğŸ’¡ **Complete Example**

```java
// Scenario:
measurements = [
    Measurement(gateway="GW_0001"),
    Measurement(gateway="GW_0001"),
    Measurement(gateway="GW_0001"),
    Measurement(gateway="GW_0002"),
    Measurement(gateway="GW_0002"),
    Measurement(gateway="GW_0003"),
    Measurement(gateway="GW_0003"),
    Measurement(gateway="GW_0003")
]

// Step 1: Count
counts = {
    "GW_0001": 3,
    "GW_0002": 2,
    "GW_0003": 3
}

// Step 2: Find max
max = 3

// Step 3: Collect gateways with max count
result = ["GW_0001", "GW_0003"]

// Return
return result;  // Both GW_0001 and GW_0003 are most active!
```

---

## ğŸ¯ **Why We Need This**

**Business Value:**
- Identify which gateways are collecting the most data
- Could indicate busier locations
- Helps with capacity planning
- Useful for network analysis

**Test Requirement:**
```java
// Tests check:
Collection<String> mostActive = report.getMostActiveGateways();
assertThat(mostActive).contains("GW_0001", "GW_0003");
```

---

## âš ï¸ **Edge Cases**

### **Case 1: Empty measurements**
```java
measurements = []

Result: []  // Empty list
```

### **Case 2: All gateways tied**
```java
measurements = [
    Measurement(gateway="GW_0001"),
    Measurement(gateway="GW_0002"),
    Measurement(gateway="GW_0003")
]

counts = {"GW_0001": 1, "GW_0002": 1, "GW_0003": 1}
max = 1

Result: ["GW_0001", "GW_0002", "GW_0003"]  // All returned!
```

### **Case 3: Single gateway**
```java
measurements = [
    Measurement(gateway="GW_0001"),
    Measurement(gateway="GW_0001"),
    Measurement(gateway="GW_0001")
]

counts = {"GW_0001": 3}
max = 3

Result: ["GW_0001"]  // Only one gateway
```

---

---

# Method 2: getLeastActiveGateways()

## ğŸ“‹ **Method Signature**

```java
@Override
public Collection<String> getLeastActiveGateways()
```

**Returns:** Collection of gateway codes (Strings)

---

## ğŸ¯ **Purpose**

**Find which gateways produced the LEAST measurements for this network.**

If multiple gateways have the same minimum count, return ALL of them.

---

## ğŸ“Š **Example Scenario**

```
Network NET_01 has measurements:
â€¢ GW_0001: 50 measurements
â€¢ GW_0002: 10 measurements
â€¢ GW_0003: 30 measurements
â€¢ GW_0004: 10 measurements  â† Tied with GW_0002!

Question: Which gateways are least active?
Answer: GW_0002 and GW_0004 (both have 10 measurements)

Result: ["GW_0002", "GW_0004"]
```

---

## ğŸ” **How It Works**

**Same logic as getMostActiveGateways(), but finds MINIMUM instead of MAXIMUM!**

### **Step 1: Count measurements per gateway**

```java
Map<String, Long> counts = new HashMap<>();
for (Measurement m : measurements) {
    String gw = m.getGatewayCode();
    counts.put(gw, counts.getOrDefault(gw, 0L) + 1);
}
```

---

### **Step 2: Find the MINIMUM count**

```java
long min = Long.MAX_VALUE;  // Start with largest possible value
for (Long val : counts.values()) {
    if (val < min) {
        min = val;
    }
}

// Result: min = lowest count
```

---

### **Step 3: Collect all gateways with minimum count**

```java
List<String> result = new ArrayList<>();
for (Map.Entry<String, Long> entry : counts.entrySet()) {
    if (entry.getValue() == min) {
        result.add(entry.getKey());
    }
}
```

---

## ğŸ’¡ **Complete Example**

```java
// Scenario:
measurements = [
    Measurement(gateway="GW_0001"),
    Measurement(gateway="GW_0001"),
    Measurement(gateway="GW_0001"),
    Measurement(gateway="GW_0001"),
    Measurement(gateway="GW_0001"),  // 5 total
    
    Measurement(gateway="GW_0002"),  // 1 total
    
    Measurement(gateway="GW_0003"),
    Measurement(gateway="GW_0003"),  // 2 total
]

// Step 1: Count
counts = {
    "GW_0001": 5,
    "GW_0002": 1,
    "GW_0003": 2
}

// Step 2: Find min
min = 1

// Step 3: Collect gateways with min count
result = ["GW_0002"]

// Return
return result;  // GW_0002 is least active
```

---

## ğŸ¯ **Why We Need This**

**Business Value:**
- Identify underutilized gateways
- Could indicate malfunctioning sensors
- May need maintenance or relocation
- Balance network load

**Test Requirement:**
```java
// Tests check:
Collection<String> leastActive = report.getLeastActiveGateways();
assertThat(leastActive).contains("GW_0002");
```

---

## âš ï¸ **Edge Cases**

### **Case 1: All gateways tied for minimum**
```java
measurements = [
    Measurement(gateway="GW_0001"),
    Measurement(gateway="GW_0002"),
    Measurement(gateway="GW_0003")
]

counts = {"GW_0001": 1, "GW_0002": 1, "GW_0003": 1}
min = 1

Result: ["GW_0001", "GW_0002", "GW_0003"]  // All tied!
```

---

---

# Method 3: getGatewaysLoadRatio()

## ğŸ“‹ **Method Signature**

```java
@Override
public Map<String, Double> getGatewaysLoadRatio()
```

**Returns:** Map where:
- **Key** = Gateway code (String)
- **Value** = Percentage of total measurements (Double)

---

## ğŸ¯ **Purpose**

**Calculate what percentage of the network's total measurements each gateway contributed.**

All percentages should add up to 100%.

---

## ğŸ“Š **Example Scenario**

```
Network NET_01 has 100 total measurements:
â€¢ GW_0001: 60 measurements â†’ 60% of total
â€¢ GW_0002: 30 measurements â†’ 30% of total
â€¢ GW_0003: 10 measurements â†’ 10% of total

Result: {
    "GW_0001": 60.0,
    "GW_0002": 30.0,
    "GW_0003": 10.0
}

Total: 60% + 30% + 10% = 100% âœ…
```

---

## ğŸ” **How It Works**

### **Step 1: Get total measurement count**

```java
double total = measurements.size();
// Example: total = 100.0
```

---

### **Step 2: Count measurements per gateway**

```java
Map<String, Long> counts = new HashMap<>();
for (Measurement m : measurements) {
    String gw = m.getGatewayCode();
    counts.put(gw, counts.getOrDefault(gw, 0L) + 1);
}

// Example:
// counts = {
//   "GW_0001": 60,
//   "GW_0002": 30,
//   "GW_0003": 10
// }
```

---

### **Step 3: Calculate percentage for each gateway**

```java
Map<String, Double> ratio = new HashMap<>();
for (Map.Entry<String, Long> entry : counts.entrySet()) {
    double val = (entry.getValue() / total) * 100.0;
    //           â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”¬â”€â”€â”˜
    //                    â”‚             â””â”€ Convert to percentage
    //                    â””â”€ Divide count by total
    
    ratio.put(entry.getKey(), val);
}

// Example:
// For GW_0001: (60 / 100) * 100 = 60.0%
// For GW_0002: (30 / 100) * 100 = 30.0%
// For GW_0003: (10 / 100) * 100 = 10.0%
```

---

## ğŸ’¡ **Complete Example**

```java
// Scenario:
measurements = [
    // 60 measurements from GW_0001
    Measurement(gateway="GW_0001"), ... (60 times)
    
    // 30 measurements from GW_0002
    Measurement(gateway="GW_0002"), ... (30 times)
    
    // 10 measurements from GW_0003
    Measurement(gateway="GW_0003"), ... (10 times)
]

// Step 1: Total
total = 100.0

// Step 2: Count per gateway
counts = {
    "GW_0001": 60,
    "GW_0002": 30,
    "GW_0003": 10
}

// Step 3: Calculate percentages
ratio = {
    "GW_0001": (60 / 100) * 100 = 60.0,
    "GW_0002": (30 / 100) * 100 = 30.0,
    "GW_0003": (10 / 100) * 100 = 10.0
}

// Return
return ratio;
```

---

## ğŸ¯ **Why We Need This**

**Business Value:**
- Understand load distribution across gateways
- Identify if one gateway is overloaded
- Balance network resources
- Capacity planning

**Test Requirement:**
```java
// Tests check:
Map<String, Double> ratios = report.getGatewaysLoadRatio();
assertThat(ratios.get("GW_0001")).isCloseTo(60.0, within(0.1));
assertThat(ratios.get("GW_0002")).isCloseTo(30.0, within(0.1));
```

---

## âš ï¸ **Edge Cases**

### **Case 1: Empty measurements**
```java
measurements = []
total = 0

Result: {}  // Empty map (can't divide by zero!)
```

### **Case 2: Single gateway**
```java
measurements = [
    Measurement(gateway="GW_0001"),
    Measurement(gateway="GW_0001"),
    Measurement(gateway="GW_0001")
]

total = 3.0
counts = {"GW_0001": 3}

ratio = {
    "GW_0001": (3 / 3) * 100 = 100.0
}

Result: {"GW_0001": 100.0}  // 100% from one gateway
```

### **Case 3: Equal distribution**
```java
measurements = [
    Measurement(gateway="GW_0001"),
    Measurement(gateway="GW_0002"),
    Measurement(gateway="GW_0003")
]

total = 3.0
counts = {"GW_0001": 1, "GW_0002": 1, "GW_0003": 1}

ratio = {
    "GW_0001": (1 / 3) * 100 = 33.333...,
    "GW_0002": (1 / 3) * 100 = 33.333...,
    "GW_0003": (1 / 3) * 100 = 33.333...
}

Total: ~99.999% (rounding error, but acceptable)
```

---

---

# Method 4: getHistogram()

## ğŸ“‹ **Method Signature**

```java
@Override
public SortedMap<Range<LocalDateTime>, Long> getHistogram()
```

**Returns:** SortedMap where:
- **Key** = Range<LocalDateTime> (time bucket)
- **Value** = Long (count of measurements in that bucket)

---

## ğŸ¯ **Purpose**

**Group measurements into time buckets and count how many measurements fall into each bucket.**

- If time range â‰¤ 48 hours â†’ **Hourly buckets**
- If time range > 48 hours â†’ **Daily buckets**

---

## ğŸ“Š **Example Scenario - Hourly**

```
Time range: 2024-01-01 10:00:00 to 2024-01-01 13:00:00
Duration: 3 hours (â‰¤ 48 hours â†’ use hourly buckets)

Measurements:
â€¢ 2024-01-01 10:30:00 â†’ Falls in bucket [10:00-11:00)
â€¢ 2024-01-01 10:45:00 â†’ Falls in bucket [10:00-11:00)
â€¢ 2024-01-01 11:15:00 â†’ Falls in bucket [11:00-12:00)
â€¢ 2024-01-01 12:30:00 â†’ Falls in bucket [12:00-13:00)
â€¢ 2024-01-01 12:45:00 â†’ Falls in bucket [12:00-13:00)

Result: {
    [2024-01-01 10:00 - 11:00): 2,
    [2024-01-01 11:00 - 12:00): 1,
    [2024-01-01 12:00 - 13:00]: 2
}
```

---

## ğŸ“Š **Example Scenario - Daily**

```
Time range: 2024-01-01 to 2024-01-05
Duration: 5 days (> 48 hours â†’ use daily buckets)

Measurements:
â€¢ 2024-01-01 14:00:00 â†’ Falls in bucket [Jan 1 00:00 - Jan 2 00:00)
â€¢ 2024-01-01 18:00:00 â†’ Falls in bucket [Jan 1 00:00 - Jan 2 00:00)
â€¢ 2024-01-02 09:00:00 â†’ Falls in bucket [Jan 2 00:00 - Jan 3 00:00)
â€¢ 2024-01-03 12:00:00 â†’ Falls in bucket [Jan 3 00:00 - Jan 4 00:00)

Result: {
    [2024-01-01 00:00 - 2024-01-02 00:00): 2,
    [2024-01-02 00:00 - 2024-01-03 00:00): 1,
    [2024-01-03 00:00 - 2024-01-04 00:00): 1,
    [2024-01-04 00:00 - 2024-01-05 00:00]: 0
}
```

---

## ğŸ” **How It Works**

### **Step 1: Determine effective time range**

```java
LocalDateTime effStart = (startDateStr != null) ? 
    LocalDateTime.parse(startDateStr, dtf) : minMeas;

LocalDateTime effEnd = (endDateStr != null) ? 
    LocalDateTime.parse(endDateStr, dtf) : maxMeas;
```

**Logic:**
- If startDate provided â†’ use it
- Otherwise â†’ use earliest measurement timestamp
- If endDate provided â†’ use it
- Otherwise â†’ use latest measurement timestamp

---

### **Step 2: Decide bucket granularity**

```java
long diffHours = ChronoUnit.HOURS.between(effStart, effEnd);
boolean hourly = (diffHours <= 48);
```

**Decision:**
- If duration â‰¤ 48 hours â†’ hourly = true (use hourly buckets)
- If duration > 48 hours â†’ hourly = false (use daily buckets)

---

### **Step 3: Create buckets**

```java
LocalDateTime bucketStart = effStart;

while (bucketStart.isBefore(effEnd) || bucketStart.equals(effEnd)) {
    // Calculate bucket end
    LocalDateTime bucketEnd;
    
    if (hourly) {
        // Hourly bucket
        bucketEnd = bucketStart.plusHours(1).truncatedTo(ChronoUnit.HOURS);
        if (bucketEnd.isAfter(effEnd)) {
            bucketEnd = effEnd;
        }
    } else {
        // Daily bucket
        bucketEnd = bucketStart.plusDays(1).truncatedTo(ChronoUnit.DAYS);
        if (bucketEnd.isAfter(effEnd)) {
            bucketEnd = effEnd;
        }
    }
    
    // Create Range object for this bucket
    // Count measurements in this bucket
    // Add to map
    
    // Move to next bucket
    bucketStart = bucketEnd;
}
```

---

### **Step 4: Create Range object**

```java
final LocalDateTime startRef = bucketStart;
final LocalDateTime endRef = bucketEnd;
final boolean isLast = bucketEnd.equals(effEnd);

Range<LocalDateTime> range = new Range<>() {
    @Override 
    public LocalDateTime getStart() { 
        return startRef; 
    }
    
    @Override 
    public LocalDateTime getEnd() { 
        return endRef; 
    }
    
    @Override 
    public boolean contains(LocalDateTime t) {
        if (t.isBefore(startRef)) return false;
        if (isLast) return !t.isAfter(endRef);  // Last bucket: [start, end]
        return t.isBefore(endRef);               // Other buckets: [start, end)
    }
};
```

**Range semantics:**
- **Normal buckets:** `[start, end)` - left-closed, right-open
  - Example: `[10:00, 11:00)` includes 10:00:00 but excludes 11:00:00
- **Last bucket:** `[start, end]` - both closed
  - Example: `[12:00, 13:00]` includes both 12:00:00 AND 13:00:00

---

### **Step 5: Count measurements in bucket**

```java
long count = 0;
for (Measurement m : measurements) {
    if (range.contains(m.getTimestamp())) {
        count++;
    }
}
```

---

### **Step 6: Add to map**

```java
map.put(range, count);
```

---

## ğŸ’¡ **Complete Example - Hourly**

```java
// Input:
startDateStr = "2024-01-01 10:00:00"
endDateStr = "2024-01-01 12:00:00"

// Step 1: Effective range
effStart = 2024-01-01 10:00:00
effEnd = 2024-01-01 12:00:00

// Step 2: Decide granularity
diffHours = 2 (â‰¤ 48 â†’ hourly = true)

// Step 3-6: Create buckets

// Bucket 1:
bucketStart = 2024-01-01 10:00:00
bucketEnd = 2024-01-01 11:00:00
range = [2024-01-01 10:00 - 11:00)
count = 5 measurements
map.put(range, 5)

// Bucket 2:
bucketStart = 2024-01-01 11:00:00
bucketEnd = 2024-01-01 12:00:00
range = [2024-01-01 11:00 - 12:00]  // Last bucket!
count = 3 measurements
map.put(range, 3)

// Result:
{
    [2024-01-01 10:00 - 11:00): 5,
    [2024-01-01 11:00 - 12:00]: 3
}
```

---

## ğŸ’¡ **Complete Example - Daily**

```java
// Input:
startDateStr = "2024-01-01 00:00:00"
endDateStr = "2024-01-03 23:59:59"

// Step 1: Effective range
effStart = 2024-01-01 00:00:00
effEnd = 2024-01-03 23:59:59

// Step 2: Decide granularity
diffHours = 71 (> 48 â†’ hourly = false, use daily)

// Step 3-6: Create buckets

// Bucket 1:
bucketStart = 2024-01-01 00:00:00
bucketEnd = 2024-01-02 00:00:00
range = [2024-01-01 00:00 - 2024-01-02 00:00)
count = 10 measurements
map.put(range, 10)

// Bucket 2:
bucketStart = 2024-01-02 00:00:00
bucketEnd = 2024-01-03 00:00:00
range = [2024-01-02 00:00 - 2024-01-03 00:00)
count = 8 measurements
map.put(range, 8)

// Bucket 3:
bucketStart = 2024-01-03 00:00:00
bucketEnd = 2024-01-03 23:59:59  // Truncated to effEnd!
range = [2024-01-03 00:00 - 2024-01-03 23:59:59]  // Last bucket!
count = 5 measurements
map.put(range, 5)

// Result:
{
    [2024-01-01 00:00 - 2024-01-02 00:00): 10,
    [2024-01-02 00:00 - 2024-01-03 00:00): 8,
    [2024-01-03 00:00 - 2024-01-03 23:59:59]: 5
}
```

---

## ğŸ¯ **Why We Need This**

**Business Value:**
- Visualize measurement distribution over time
- Identify patterns (busy hours, quiet days)
- Detect anomalies (sudden spikes or gaps)
- Generate charts/graphs for reports

**Test Requirement:**
```java
// Tests check:
SortedMap<Range<LocalDateTime>, Long> histogram = report.getHistogram();

// Check buckets exist
assertThat(histogram).hasSize(expectedBuckets);

// Check counts
for (Map.Entry<Range<LocalDateTime>, Long> entry : histogram.entrySet()) {
    assertThat(entry.getValue()).isGreaterThanOrEqualTo(0);
}
```

---

## âš ï¸ **Edge Cases**

### **Case 1: Empty measurements**
```java
measurements = []

Result: {}  // Empty map
```

### **Case 2: Exactly 48 hours**
```java
startDate = "2024-01-01 00:00:00"
endDate = "2024-01-03 00:00:00"  // Exactly 48 hours

diffHours = 48 (â‰¤ 48 â†’ use hourly buckets)

Result: 48 hourly buckets
```

### **Case 3: 48 hours + 1 minute**
```java
startDate = "2024-01-01 00:00:00"
endDate = "2024-01-03 00:01:00"  // 48 hours + 1 minute

diffHours = 48 (â‰¤ 48... wait, 00:01 makes it more!)
Actually: ChronoUnit.HOURS.between truncates, so still 48

diffHours = 48 (â‰¤ 48 â†’ use hourly buckets)
```

### **Case 4: Partial first/last buckets**
```java
startDate = "2024-01-01 10:30:00"  // Not at hour boundary
endDate = "2024-01-01 12:45:00"    // Not at hour boundary

Buckets:
[2024-01-01 10:30 - 11:00): Partial hour (30 min)
[2024-01-01 11:00 - 12:00): Full hour
[2024-01-01 12:00 - 12:45]: Partial hour (45 min)
```

---

## ğŸ”‘ **Key Concepts**

### **Range Semantics**

```
Normal bucket: [10:00, 11:00)
â€¢ Includes: 10:00:00, 10:30:00, 10:59:59
â€¢ Excludes: 11:00:00

Last bucket: [12:00, 13:00]
â€¢ Includes: 12:00:00, 12:30:00, 13:00:00
â€¢ Everything inside (both endpoints!)
```

**Why different?**
- Prevents measurements at bucket boundaries from being lost
- Ensures maximum timestamp is counted

---

### **SortedMap**

```java
SortedMap<Range<LocalDateTime>, Long> map = new TreeMap<>(...);
```

**Properties:**
- Keys sorted by start time (ascending)
- Iterating gives buckets in chronological order
- First entry = earliest bucket
- Last entry = latest bucket

---

---

# Summary: Why All Four Methods Exist

## ğŸ“‹ **Checklist**

| Reason | Explanation |
|--------|-------------|
| âœ… **Interface Contract** | NetworkReportImpl implements NetworkReport interface â†’ MUST implement all methods |
| âœ… **R1 Requirements** | Project README specifies these statistics must be in NetworkReport |
| âœ… **Test Requirements** | Tests call these methods and expect specific results |
| âœ… **Business Value** | Each method provides useful analytics for network monitoring |

---

## ğŸ¯ **What Each Method Does**

| Method | Purpose | Returns | Example |
|--------|---------|---------|---------|
| `getMostActiveGateways()` | Find gateways with most measurements | Collection of gateway codes | `["GW_0001", "GW_0003"]` |
| `getLeastActiveGateways()` | Find gateways with least measurements | Collection of gateway codes | `["GW_0002"]` |
| `getGatewaysLoadRatio()` | Calculate percentage per gateway | Map of code â†’ percentage | `{"GW_0001": 60.0, "GW_0002": 40.0}` |
| `getHistogram()` | Group measurements into time buckets | Map of time range â†’ count | `{[10:00-11:00): 5, [11:00-12:00]: 3}` |

---

## âœ… **Final Understanding**

**These methods exist because:**

1. **Interface forces us** - We implement NetworkReport, so we MUST implement these
2. **Requirements demand it** - R1 specification requires these statistics
3. **Tests expect them** - Tests call these methods and verify results
4. **Users need them** - Provide valuable network analytics

**Without these methods:**
- âŒ Code won't compile (interface not fully implemented)
- âŒ Tests will fail
- âŒ R1 requirement incomplete
- âŒ Users can't get network statistics

**With these methods:**
- âœ… Code compiles
- âœ… Tests pass
- âœ… R1 requirement complete
- âœ… Users get valuable network analytics

---

**END OF DOCUMENT**